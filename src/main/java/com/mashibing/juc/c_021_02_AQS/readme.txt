https://blog.csdn.net/qq_30572275/article/details/80297047
reetrantLock详细说明 zhengxin
1.构造方法 可以传递Boolean 类型变量 实现公平和非公平  默认不传递 是非公平锁
2.lock()
没有返回值 加锁失败会阻塞 首先调用cas操作  尝试将父类（aqs）中的state设置成1，如果成功那么加锁成功，失败了会调用父类的acquire方法
这个方法首先会调用需要子类实现的tryAcquire() 获取当前的state 如果是0那么再次枪锁 如果不是0 并且线程是当前获得锁的线程 那么记录冲入次数 state + 1
如果再次枷锁失败将当前线程封装成Node 放入到队列中 添加Node的过程是个循环的过程 采用cas操作 想链表尾部添加节点  知道添加成功为止
节点成功添加到队列之后进行自旋抢锁  如果当前节点的前置节点是头结点 那么进行尝试抢锁 调用子类实现的tryacquire方法 如果成功了将当前节点设置成头节点
如果失败了 就判断当前线程是否需要进入等待状态 将前面的不需要抢锁的节点移除 如果前面的节点是正常的需要抢锁的节点 那么将前面的节点的waitstatus设置成-1
线程进入等待状态  等待前置节点进行唤醒操作

补充知识：线程的interrupt  interrupted Isinterruptde 三个方法的区别 第一个对象方法会让当前调用的线程对象的中断标志设置成true 第二个方法 是静态方法获取的
是当前的线程 返回中断状态的同时经中断状态重置，第三个方法是对象方法 返回当前线程对象的中断状态 不会重置中断状态 2，3调用的是同一个native方法 参数一个是true 一个是false
线程处于等待 阻塞中 调用interrupt 会抛出异常  当时使用lockSupport进行想成挂起调用中断方法 线程会继续执行

3.unlock()